package com.fx.login.service;

import com.fx.login.model.*;
import com.fx.login.repo.PaymentCycleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Service
@Transactional
public class FeeGenerationService {

    @Autowired
    private PaymentCycleRepository paymentCycleRepository;

    @Autowired
    private UnpaidService unpaidService;

    @Autowired
    private ResidentService residentService;

    @Autowired
    private PaymentCycleService paymentCycleService;

    // ‚è∞ T·ª∞ ƒê·ªòNG CH·∫†Y H√ÄNG NG√ÄY L√öC 00:30
    @Scheduled(cron = "0 30 0 * * *")
    public void autoGenerateDailyFees() {
        System.out.println("üîÑ [" + LocalDate.now() + "] B·∫Øt ƒë·∫ßu ki·ªÉm tra chu k·ª≥ t·∫°o kho·∫£n thu...");

        try {
            List<PaymentCycleEntity> activeCycles = paymentCycleRepository.findByActiveTrue();

            for (PaymentCycleEntity cycle : activeCycles) {
                if (shouldGenerateToday(cycle)) {
                    generateFeesForCycle(cycle);
                }
            }

            System.out.println("‚úÖ Ho√†n th√†nh ki·ªÉm tra chu k·ª≥ t·ª± ƒë·ªông!");

        } catch (Exception e) {
            System.err.println("‚ùå L·ªói trong qu√° tr√¨nh t·ª± ƒë·ªông t·∫°o kho·∫£n thu: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // Ki·ªÉm tra c√≥ n√™n t·∫°o kho·∫£n thu h√¥m nay kh√¥ng
    private boolean shouldGenerateToday(PaymentCycleEntity cycle) {
        LocalDate today = LocalDate.now();
        LocalDate nextDue = cycle.getNextDue();

        return nextDue.equals(today) || nextDue.isBefore(today);
    }

    // T·∫†O KHO·∫¢N THU CHO M·ªòT CHU K·ª≤ (Manual trigger by admin)
    public List<UnpaidEntity> generateFeesForCycle(PaymentCycleEntity cycle) {
        System.out.println("üìù T·∫°o kho·∫£n thu cho chu k·ª≥: " + cycle.getFee().getFeeName());

        List<UnpaidEntity> newFees = new ArrayList<>();
        FeeEntity fee = cycle.getFee();

        List<Resident> residents = residentService.findAll();

        for (Resident resident : residents) {
            if (!isAlreadyGenerated(cycle, resident)) {
                UnpaidEntity unpaid = createUnpaidForResident(cycle, resident);
                UnpaidEntity savedUnpaid = unpaidService.createUnpaid(unpaid);
                newFees.add(savedUnpaid);
            }
        }

        // C·∫≠p nh·∫≠t chu k·ª≥
        paymentCycleService.updateCycleAfterGeneration(cycle);

        System.out.println("‚úÖ ƒê√£ t·∫°o " + newFees.size() + " kho·∫£n thu m·ªõi");
        return newFees;
    }

    // T·∫°o kho·∫£n thu ƒë·ªôt xu·∫•t (ONE_TIME)
    public List<UnpaidEntity> createOneTimeFees(FeeEntity fee, LocalDate dueDate, String description) {
        System.out.println("üí∞ T·∫°o kho·∫£n thu ƒë·ªôt xu·∫•t: " + fee.getFeeName());

        List<UnpaidEntity> newFees = new ArrayList<>();
        List<Resident> residents = residentService.findAll();

        for (Resident resident : residents) {
            UnpaidEntity unpaid = new UnpaidEntity();
            unpaid.setFeeID(fee.getId());
            unpaid.setResidentName(resident.getFullName());
            unpaid.setApartmentName(resident.getApartmentNumber());
            unpaid.setTotalPayment(fee.getAmountDue());
            unpaid.setDueDate(dueDate.toString());
            unpaid.setStatus("PENDING");
            unpaid.setDescription(description != null ? description : "Kho·∫£n thu ƒë·ªôt xu·∫•t - " + fee.getFeeName());

            UnpaidEntity savedUnpaid = unpaidService.createUnpaid(unpaid);
            newFees.add(savedUnpaid);
        }

        System.out.println("‚úÖ ƒê√£ t·∫°o " + newFees.size() + " kho·∫£n thu ƒë·ªôt xu·∫•t");
        return newFees;
    }

    // Helper methods
    private boolean isAlreadyGenerated(PaymentCycleEntity cycle, Resident resident) {
        List<UnpaidEntity> existingFees = unpaidService.findByFeeID(cycle.getFee().getId());

        return existingFees.stream().anyMatch(unpaid ->
                resident.getFullName().equals(unpaid.getResidentName()) &&
                        resident.getApartmentNumber().equals(unpaid.getApartmentName()) &&
                        unpaid.getDueDate() != null &&
                        unpaid.getDueDate().equals(cycle.getNextDue().toString())
        );
    }

    private UnpaidEntity createUnpaidForResident(PaymentCycleEntity cycle, Resident resident) {
        FeeEntity fee = cycle.getFee();

        UnpaidEntity unpaid = new UnpaidEntity();
        unpaid.setFeeID(fee.getId());
        unpaid.setResidentName(resident.getFullName());
        unpaid.setApartmentName(resident.getApartmentNumber());
        unpaid.setTotalPayment(fee.getAmountDue());
        unpaid.setDueDate(cycle.getNextDue().toString());
        unpaid.setStatus("PENDING");
        unpaid.setDescription(createFeeDescription(fee, cycle));

        return unpaid;
    }

    private String createFeeDescription(FeeEntity fee, PaymentCycleEntity cycle) {
        String cycleDisplay = getCycleTypeDisplay(cycle.getCycleType());
        String period = generatePeriodDescription(cycle.getNextDue(), cycle.getCycleType());

        return String.format("Ph√≠ %s (%s) - %s",
                fee.getFeeName(),
                cycleDisplay,
                period
        );
    }

    private String getCycleTypeDisplay(String cycleType) {
        return switch (cycleType) {
            case "MONTHLY" -> "h√†ng th√°ng";
            case "QUARTERLY" -> "h√†ng qu√Ω";
            case "YEARLY" -> "h√†ng nƒÉm";
            case "ONE_TIME" -> "ƒë·ªôt xu·∫•t";
            default -> cycleType;
        };
    }

    private String generatePeriodDescription(LocalDate dueDate, String cycleType) {
        return switch (cycleType) {
            case "MONTHLY" -> "Th√°ng " + dueDate.getMonthValue() + "/" + dueDate.getYear();
            case "QUARTERLY" -> "Qu√Ω " + ((dueDate.getMonthValue() - 1) / 3 + 1) + "/" + dueDate.getYear();
            case "YEARLY" -> "NƒÉm " + dueDate.getYear();
            default -> dueDate.toString();
        };
    }
}